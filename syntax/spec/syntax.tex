\documentclass[../main.tex]{subfiles}
\begin{document}
\section{Syntax}\label{section:syntax}
\subsection{Base types and 44 ast nodes}
In regex notation, we provide the following means of describing literals as well as the specification of the constants T and F.
    \begin{center}
    \begin{tabular}{c c c}
        \texttt{var} & ::= & [a-z][a-zA-Z0-9]* \\
        \texttt{int} & ::= & "-"? [0-9]+ \\
        \texttt{byte} & ::= & "0x" [0-9a-fA-F] \\
        \texttt{bytestring} & ::= & "0x" [0-9a-fA-F]+ \\
        \texttt{text} & ::= & <too tough to get latex to compile it lol>  \\
        \texttt{bool} & ::= & [TF] \\
        \texttt{unit} & ::= & [()]
    \end{tabular}
    \end{center}
    \label{tab:atomsregex}

Additionally, we have builtins as follows, (with semantics given in \ref{section:dynamics}). \textbf{Morgan: should a let ast node be in this list of builtins??}
\begin{grammar}
    <builtin> ::=
        "AddInteger" \alt "SubtractInteger" \alt "MultiplyInteger"
        \alt "DivideInteger" \alt "QuotientInteger" \alt "RemainderInteger"
        \alt "ModInteger" \alt "EqualsInteger" \alt "LessThanInteger"
        \alt "LessThanEqualsInteger" \alt "AppendByteString"
        \alt "ConsByteString" \alt "SliceByteString" \alt "LengthByteString"
        \alt "IndexByteString" \alt "EqualsByteString" \alt "LessThanByteString"
        \alt "LessThanEqualsByteString" \alt "Sha2_256" \alt "Sha3_256" \alt "Blake2b_256"
        \alt "VerifySignature" \alt "AppendString" \alt "EqualsString"
        \alt "EncodeUtf8" \alt "DecodeUtf8" \alt "IfThenElse" \alt "ChooseUnit"
        \alt "MkCons" \alt "HeadList" \alt "TailList" \alt "NullList"
        \alt "ChooseData" \alt "ConstrData" \alt "MapData" \alt "ListData"
        \alt "IData" \alt "BData" \alt "UnConstrData" \alt "UnMapData"
        \alt "EqualsData" \alt "MkPairData" \alt "MkNilData" \alt "MkNilPairData"
\end{grammar}

Many of which have syntax sugars for infix application, like so
\begin{grammar}
    <infixbuiltin> ::=
        "+i" \alt "-i" \alt "*i" \alt "/i" \alt "//i" \alt $\%$"i" \alt "==i" \alt "lti" \alt $\leq$"i" \alt "+b" \alt ":b" \alt "!b" \alt "==b" \alt "ltb" \alt $\leq$"b" \alt "+s" \alt "==s" \alt "==d"
\end{grammar}
\textit{Sorry, having trouble getting lessthan sign to render rn}. In the small step dynamics given in \ref{section:dynamics}, only abstract syntax (i.e. $<builtin>$) will be provided, not concrete syntax (i.e. including sugar).

\end{document}
